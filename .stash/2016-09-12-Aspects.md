---
layout:     post
title:      "iOS平台面向切面编程的应用及Aspects源码探究"
subtitle:   "Aspects源码解析及应用出现问题的思考"
date:       2016-09-12 13:40:00
author:     "Shin Cheung"
header-img: "img/post-bg-ios9-web.jpg"
header-mask: 0.3
catalog:    true
tags:
    - iOS
    - 源码阅读
---

## 1、前记

近日，项目新增自定义事件打点的需求。按照往常的打点做法，在需求打点的代码处直接加上事件代码就结束了。但是发现业务逻辑和打点逻辑相互耦合，需要改动的地方又是甚多，一个个文件去改实在是效率低下，而且影响了原有的业务逻辑代码的，使打点逻辑代码很是分散，不宜作一个统一的管理。因此决定选择一种优雅的实现方式去做打点的需求。考虑到 Objective-C 语言的动态性，利用 runtime 机制去做 method swizzling 也是很容易去实现的。

想起曾经读过 rollout.io 的 [Rollout Under The Hood – 2016 Update](https://blog.rollout.io/2016/03/under-the-hood-2016-update/) 这篇博文中提到 Method Swizzling 的正确与错误的实现方式 [New Relic blog: The Right Way to Swizzle in Objective-C](https://blog.newrelic.com/2014/04/16/right-way-to-swizzle/)  及 NSHipster的文章 [Method Swizzling](http://nshipster.com/method-swizzling/) 。感觉自行 `hook` 每个需要打点的 `Class` 还是很无聊的。还好 iOS 平台上有一个 swizzling method 的开源框架 [Aspects](https://github.com/steipete/Aspects) , 使用方便，一共也就2个方法。

```objectivec

/// Adds a block of code before/instead/after the current `selector` for a specific class.
///
/// @param block Aspects replicates the type signature of the method being hooked.
/// The first parameter will be `id<AspectInfo>`, followed by all parameters of the method.
/// These parameters are optional and will be filled to match the block signature.
/// You can even use an empty block, or one that simple gets `id<AspectInfo>`.
///
/// @note Hooking static methods is not supported.
/// @return A token which allows to later deregister the aspect.
+ (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// Adds a block of code before/instead/after the current `selector` for a specific instance.
- (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

```

提供的功能很满足当前的需求，遂引入到自己的项目中。

## 2、利用Aspects打点

定义一个合适的打点入口，如自己项目中：

```objectivec
@interface EventLogger : NSObject

+ (void)startLogEvents;

@end

@implementation EventLogger

+ (void)startLogEvents
{
	// aspects hook
	//...
	[UIViewController aspect_hookSelector:@selector(init)
                              withOptions:(AspectPositionAfter)
                               usingBlock:^(id<AspectInfo> info){
                                   id obj = info.instance;
                                   if ([obj respondsToSelector:@selector(addLogger)]) {
                                       [obj addLogger];
                                   }
                               } error:NULL];
	//...
}

@end

```
比如统计某个 `UIViewController` 的展现了多少次，则可以在 `EventLogger` 中对指定的 `ViewController` 作如下处理即可：

```objectivec
@interface ViewController (EventLogger)
- (void)addLogger;
@end

@implementation ViewController (EventLogger)

- (void)addLogger
{
    [self aspect_hookSelector:@selector(viewDidLoad)
                  withOptions:(AspectPositionAfter)
                   usingBlock:^(id<AspectInfo> info) {
                       log_event(XXXViewController_Load);
                   } error:NULL];                   
}

@end
```

这样就很简单的隔离了业务逻辑代码和打点逻辑代码，仅仅在打点逻辑的文件中对需要打点的对象处理了，简单易维护，比自己手动做 swizzling method 简单方便，还可以选择特定的 AspectOptions 。

因为本文主要是对 Aspects 的实现原理做一下梳理，以便能更好的学习和掌握这些知识，故不再过多的描述本项目中的打点实现逻辑了。接下来就是分析源码了。

## 3、基本原理

#### 3.1 OC 的消息转发机制

我们都知道 OC 中的方法调用，`[obj message]` 实际上等同于 `objc_msgSend(obj, @selector(message))`, 这个过程就是根据 `message` 生成 `selector` ，然后根据 `selector` 寻找指向该函数的具体实现的函数指针 `IMP`，然后才能根据 `IMP` 正确的执行该函数的逻辑。这就是一个消息的转发过程。swizzling method 就是动态的改变了 `selector` 的 `IMP` 来实现改变原有的函数实现。

在NSHipster的文章 [Method Swizzling](http://nshipster.com/method-swizzling/) 中推荐我们在 `+ (void)load` 方法中去做 swizzling method 。但这样做，不利于很好的提供一个统一的替换入口，而且相对于 Aspects 提供的功能，还是有差距的。

Aspects 为了能够顺利的完成消息转发，就利用 OC 语言自己的消息转发机制。我们可以先看看消息是如何寻找对应的 `IMP` 的。
如下图(非原创，图中 `IML` 改为 `IMP` 更合适)：![](http://img.blog.csdn.net/20160629125258569)

想更深入的了解消息的转发，请阅读 draveness 的博文 [从源代码看 ObjC 中消息的发送](http://draveness.me/message/)。

#### 3.2 合适的入口

从上图中可以看出，在消息转发的过程中， 如果 `selector` 有对应的 `IMP`，则直接执行；如果没有，则提供几次机会去寻找 `IMP`，如图中描述的 `resolveInstanceMethod `、`forwardingTargetForSelector ` 和 `forwardInvocation `。`forwardInvocation `相对于前 2 个，更灵活，我们知道 `NSInvocation` 可以携带一系列消息转发所需的信息元素，正如文档中描述的这般：

>An NSInvocation object contains all the elements of an Objective-C message: a target, a selector, arguments, and the return value. Each of these elements can be set directly, and the return value is set automatically when the NSInvocation object is dispatched.
>

Aspects 选择在 `forwardInvocation ` 中去处理 hook 再合适不过了。

#### 3.3 Aspects 的实现原理

Aspects 对于需要 `hook` 的 `selector` ，将其 `IMP` 指向 `objc_msgForward / _objc_msgForward_stret` ，同时生成一个 `aliasSelector` 去保存原有的 `IMP` 。然后 `hook` 了 `forwardInvocation` 函数，使其指向自己定义的 `__ASPECTS_ARE_BEING_CALLED__` ，实现 Aspects 自己的消息转发逻辑。

这样，即可以实现 hook ，又可以提供丰富的功能，如选择 hook 后操作的 position（before，instead， after，removal）。

## 4、源码解析

### 4.1 主要的数据结构

#### 4.1.1 .h中的数据结构

##### 4.1.1.1 AspectOptions

```objectivec
typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.
    
    AspectOptionAutomaticRemoval = 1 << 3 /// Will remove the hook after the first execution.
};
```

##### 4.1.1.2 AspectInfo (Protocol)

```objectivec
/// The AspectInfo protocol is the first parameter of our block syntax.
@protocol AspectInfo <NSObject>

/// The instance that is currently hooked.
- (id)instance;

/// The original invocation of the hooked method.
- (NSInvocation *)originalInvocation;

/// All method arguments, boxed. This is lazily evaluated.
- (NSArray *)arguments;

@end
```

AspectInfo 主要用于 block 回调时，隐藏内部对象的实现，只暴露关键的 `instance` 、 `originalInvocation`  的属性及 `-(void)arguments; `方法。

##### 4.1.1.3 NSObject (Aspects)

```objectivec
/**
 Aspects uses Objective-C message forwarding to hook into messages. This will create some overhead. Don't add aspects to methods that are called a lot. Aspects is meant for view/controller code that is not called a 1000 times per second.

 Adding aspects returns an opaque token which can be used to deregister again. All calls are thread safe.
 */
@interface NSObject (Aspects)

/// Adds a block of code before/instead/after the current `selector` for a specific class.
///
/// @param block Aspects replicates the type signature of the method being hooked.
/// The first parameter will be `id<AspectInfo>`, followed by all parameters of the method.
/// These parameters are optional and will be filled to match the block signature.
/// You can even use an empty block, or one that simple gets `id<AspectInfo>`.
///
/// @note Hooking static methods is not supported.
/// @return A token which allows to later deregister the aspect.
+ (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// Adds a block of code before/instead/after the current `selector` for a specific instance.
- (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

@end
```

在 NSObject 的 Category 中定义 2 个方法， 1）类方法；2）实例方法。<br>
需要注意的是，类方法并不是 hook 类方法的。

#### 4.1.2 .m中的数据结构

##### 4.1.2.1 AspectsInfo

```objectivec
@interface AspectInfo : NSObject <AspectInfo>
- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;
@property (nonatomic, unsafe_unretained, readonly) id instance;
@property (nonatomic, strong, readonly) NSArray *arguments;
@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;
@end
```

是遵循 AspectInfo (Protocol) 的内部具体定义，主要包含了 hook 了的对象 instance，原有的 invocation 等。

##### 4.1.2.2 AspectIdentifier

```objectivec
// Tracks a single aspect.
@interface AspectIdentifier : NSObject
+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;
- (BOOL)invokeWithInfo:(id<AspectInfo>)info;
@property (nonatomic, assign) SEL selector;
@property (nonatomic, strong) id block;
@property (nonatomic, strong) NSMethodSignature *blockSignature;
@property (nonatomic, weak) id object;
@property (nonatomic, assign) AspectOptions options;
@end
```

##### 4.1.2.3 AspectsContainer

```objectivec
// Tracks all aspects for an object/class.
@interface AspectsContainer : NSObject
- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;
- (BOOL)removeAspect:(id)aspect;
- (BOOL)hasAspects;
@property (atomic, copy) NSArray *beforeAspects;
@property (atomic, copy) NSArray *insteadAspects;
@property (atomic, copy) NSArray *afterAspects;
@end
```

##### 4.1.2.4 AspectTracker

```objectivec
@interface AspectTracker : NSObject
- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;
@property (nonatomic, strong) Class trackedClass;
@property (nonatomic, strong) NSMutableSet *selectorNames;
@property (nonatomic, weak) AspectTracker *parentEntry;
@end
```

##### 4.1.2.5 _AspectBlock

```objectivec
typedef struct _AspectBlock {
	__unused Class isa;
	AspectBlockFlags flags;
	__unused int reserved;
	void (__unused *invoke)(struct _AspectBlock *block, ...);
	struct {
		unsigned long int reserved;
		unsigned long int size;
		// requires AspectBlockFlagsHasCopyDisposeHelpers
		void (*copy)(void *dst, const void *src);
		void (*dispose)(const void *);
		// requires AspectBlockFlagsHasSignature
		const char *signature;
		const char *layout;
	} *descriptor;
	// imported variables
} *AspectBlockRef;
```

### 4.2 代码流程

## 总结


